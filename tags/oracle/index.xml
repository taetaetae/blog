<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>oracle - Tag - 👨‍💻꿈꾸는 태태태의 공간</title><link>https://taetaetae.github.io/tags/oracle/</link><description>oracle - Tag - 👨‍💻꿈꾸는 태태태의 공간</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Tue, 04 Apr 2017 11:41:28 +0000</lastBuildDate><atom:link href="https://taetaetae.github.io/tags/oracle/" rel="self" type="application/rss+xml"/><item><title>mybatis insert/update 쿼리실행후 결과 가져오기</title><link>https://taetaetae.github.io/2017/04/04/mybatis-use-generated-keys/</link><pubDate>Tue, 04 Apr 2017 11:41:28 +0000</pubDate><author>Author</author><guid>https://taetaetae.github.io/2017/04/04/mybatis-use-generated-keys/</guid><description><![CDATA[<div class="featured-image">
                <img src="/images/mybatis-useGeneratedKeys/mybatis.png" referrerpolicy="no-referrer">
            </div>Select문이 아닌 다른 SQL Query(insert, update 등) 를 실행하고서 결과를 봐야하는 상황이 생긴다. 정확히 잘 수행되었나에 대한 확인. 어떻게 쿼리가 잘 수행되었나를 확인하는 방법은 다음과 같다. ※ 참고 url : http://www.mybatis.org/mybatis-3/ko/sqlmap-xml.html
useGeneratedKeys, keyProperty 옵션 사용하는 데이터베이스가 자동생성키를 지원한다면(mySql 같은) 해당옵션을 이용해 결과를 리턴 받을수 있다. 예로들어 파라미터로 아래 모델객체를 넘긴다고 가정하고
public Student { int id; String name; String email; Date regist_date; } 아래 mybatis 구문으로 insert를 시도하게되면, 파라미터로 넘긴 Student 객체의 id값에 insert 했을때의 key값(id)이 들어오게 된다.
Student student = new Student(); student.setName(&#39;bla&#39;); student.setEmail(&#39;bla@naver.com&#39;); mapper.insertStudents(student); // 쿼리실행 student.getId(); // 추출 가능 &lt;insert id=&#34;insertStudents&#34; useGeneratedKeys=&#34;true&#34; keyProperty=&#34;id&#34; parameterType=&#34;Student&#34;&gt; insert into Students ( name, email ) values ( #{name}, #{email} ) &lt;/insert&gt; selectKey 옵션 Oracle 같은 경우는 Auto Increment 가 없고 Sequence를 사용해야만 하기 때문에 위 옵션을 사용할수가 없다. 하지만 다른 우회적인(?) 방법으로 위와같은 효과를 볼수가 있다. 파라미터의 모델이나 java구문은 위와 동일하고 xml 쿼리 부분만 아래와 같이 설정해주면 된다.
&lt;insert id=&#34;insertStudents&#34; parameterType=&#34;Student&#34;&gt; &lt;selectKey keyProperty=&#34;id&#34; resultType=&#34;int&#34; order=&#34;BEFORE&#34;&gt; select SEQ_ID.nexyval FROM DUAL &lt;/selectKey&gt; insert into Students (id, name , email) values (#{id}, #{name}, #{email}) &lt;/insert&gt; 위와같은 코드에서 쿼리가 실행되기 전에 id값에 Sequence에 의해 값을 셋팅하게 되고, 자동적으로 해당 값을 Student의 id에 set하게 되서 동일한 결과를 볼수가 있다.
항상 테이블의 key값에만 해당하는것이 아니다. key값과는 전혀 상관없는 값도 selectKey 구문으로 리턴할수가 있는데 order옵션을 AFTER로 주고 리턴하고자 하는 값을 명시해주면 된다. 아래 코드에서는 입력할시 id값을 Sequence에서 가져오는게 아니라 수동으로 넣어주고, 입력했던 id에 맞는 regist_date 값을 리턴받아 위에서처럼 동일하게 값를 가져올수 있다.
&lt;insert id=&#34;insertStudents&#34; parameterType=&#34;Student&#34;&gt; &lt;selectKey keyProperty=&#34;regist_date&#34; resultType=&#34;java.util.Date&#34; order=&#34;AFTER&#34;&gt; select regist_date FROM students WHERE id = #{id} &lt;/selectKey&gt; insert into Students (id, name , email, regist_date) values (#{id}, #{name}, #{email}, syadate) &lt;/insert&gt; ]]></description></item><item><title>Oracle + Mybatis 환경에서의 Date 다루기</title><link>https://taetaetae.github.io/2017/03/23/oracle-mybatis-date/</link><pubDate>Thu, 23 Mar 2017 11:16:05 +0000</pubDate><author>Author</author><guid>https://taetaetae.github.io/2017/03/23/oracle-mybatis-date/</guid><description><![CDATA[<div class="featured-image">
                <img src="/images/oracle-mybatis-date/oracle_mybatis_date.png" referrerpolicy="no-referrer">
            </div>상황  Oracle, Java 8, mybatis3 환경 Date컬럼에 데이터가 있는데 이를 select query로 조회하여 Model에 바인딩 시키고자 함.   쿼리에 아무 기능을 추가하지 않고 Date 형태로 Model에 바인딩을 하면 시분초가 없어진 2017-01-01 00:00:00 형태로 남게됨 그래서 아래처럼 쿼리 작성할 때마다 TO_CHAR를 사용해서 포맷에 맞추어 형변환을 시키고 Date 또는 String으로 Model에 바인딩 하곤 했음.  SELECT TO_CHAR(reg_ymdt, &#39;YYYY-MM-DD HH24:MI:SS&#39;) AS registDate FROM ...  이렇게 하다보니 query 만들때마다 형변환하는 쿼리를 만들어줘야하고, 자칫 포맷형식을 다르게 적으면 엉뚱한 결과를 초래하거나, Date형을 그대로 받아 사용해야하는 상황에서는 다시 형변환하는 과정(String to Date)을 해줘야만 함. .. 귀차니즘의 시작 : 삽질  1. 삽질의 시작 1-1. 오라클의 DATE형 → java.sql.Date 의 경우  mybatis에서는 자동적으로 org.apache.ibatis.type.SqlDateTypeHandler를 호출하게됨 mybatis 3 문서 참고 해당 핸들러의 내부 데이터 변환 코드는 다음과 같음  @Override public Date getNullableResult(ResultSet rs, String columnName) throws SQLException { return rs.getDate(columnName); }  java.sql.ResultSet.getDate()메소드를 호출하면 실제 &lsquo;yyyy-mm-dd&rsquo; 만 가져와 리턴하게됨 (여기서 디버깅 해보면 rs.getTimestamp(columnName)값은 시분초까지 다 들어가 있음) 따라서 시간값이 없는 yyyy-mm-dd 형태로 리턴이 됨  1-2. 오라클의 DATE형 → java.util.Date 의 경우  mybatis에서는 자동적으로 org.apache.ibatis.type.DateOnlyTypeHandler를 호출하게됨 mybatis 3 문서 참고 해당 핸들러의 내부 데이터 변환 코드는 다음과 같음  @Override public Date getNullableResult(ResultSet rs, String columnName) throws SQLException { java.sql.Date sqlDate = rs.getDate(columnName); if (sqlDate != null) { return new java.util.Date(sqlDate.getTime()); } return null; }  위의 org.apache.ibatis.type.SqlDateTypeHandler 변환코드에서 발생한 문제점과 같이 yyyy-mm-dd 만 가져와서 java.sql.Date 객체를 만들고, 이 정보를 토대로 java.util.Date 객체를 만들게 되는데 앞서 시간값을 뺀 정보로 만들어졌기 때문에 결국 동일하게 yyyy-mm-dd 형태로 리턴이 됨  2. 삽질완료, 해결의 시작  오라클 + mybatis 환경에서 Date타입을 다루기 위해서는 타입핸들러를 명시적으로 만들어줘야 한다는걸 알게됨.  2-1. 오라클의 DATE형 → java.sql.Date 의 경우  아래처럼 코드를 작성하여 커스텀 핸들러를 만들어 등록을 시켜준다. mybatis-config.xml  &lt;typeHandlers&gt; &lt;typeHandler handler=&#34;com.naver.dbill.admin.common.handler.CustomDateHandler&#34;/&gt; &lt;/typeHandlers&gt;  CustomDateHandler.java  ... import java.sql.Date; ... public class CustomDateHandler extends BaseTypeHandler&lt;Date&gt; { ... @Override public Date getNullableResult(ResultSet rs, String columnName) throws SQLException { Timestamp sqlTimestamp = rs.getTimestamp(columnName); if (sqlTimestamp != null) { return new Date(sqlTimestamp.getTime()); } return null; } ... }  위 코드를 작성하고 실행해보면 정상적으로 시분초 값이 있는 완전한 Date 형태를 볼수 있다.  2-2. 오라클의 DATE형 → java.util.Date 의 경우  아래처럼 코드를 작성하여 커스텀 핸들러를 만들어 등록을 시켜준다. 단, mybatis 3 문서를 보면 java.sql.Date 와는 다르게 기본으로 설정된 typeHandler가 JDBC에 따라 3가지가 있다. 따라서 작성한 커스텀 핸들러를 적용하기 위해서는 명시적으로 자바타입 과 JDBC타입 을 적어줘야 정상적으로 오버라이딩이 되어 해당 핸들러를 사용하게 된다. mybatis-config.xml  &lt;typeHandlers&gt; &lt;typeHandler handler=&#34;com.naver.dbill.admin.common.handler.CustomDateHandler&#34; javaType=&#34;java.util.Date&#34; jdbcType=&#34;DATE&#34;/&gt; &lt;/typeHandlers&gt;  CustomDateHandler.java 는 위와 동일하다. ( import java.util.Date; 사용으로 변경 )  삽질하며 알게된 보너스 지식  java.sql.Date 는 java.util.Date 을 상속받았다.  public class Date extends java.util.Date { }  검색을 하다보면 알수있겠지만 java.sql.Date 는 JDBC등을 이용해서 데이터베이스의 데이터를 사용하는데 적합하고, java.util.Date 은 보다 범용적인 날짜나 시각정보를 다룰때 적합하다고 한다. toString 메소드의 리턴 Format 형태  java.sql.Date : yyyy-mm-dd java.util.Date : EEE MMM dd HH:mm:ss zzz yyyy   mybatis 에서 형변환은 mybatis 3 문서에 나와있는 자바타입과 JDBC타입이 일치할 경우에 해당 타입 핸들러를 기본으로 사용하게 된다.  정상혁 님 조언 ( http://d2.naver.com/helloworld/645609 작성하신분 )  Oracle의 JDBC 드라이버가 예상 밖으로 동작하네요.]]></description></item></channel></rss>