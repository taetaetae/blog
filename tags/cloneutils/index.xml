<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>cloneUtils - Tag - 👨‍💻꿈꾸는 태태태의 공간</title><link>https://taetaetae.github.io/tags/cloneutils/</link><description>cloneUtils - Tag - 👨‍💻꿈꾸는 태태태의 공간</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Tue, 21 Aug 2018 18:02:47 +0000</lastBuildDate><atom:link href="https://taetaetae.github.io/tags/cloneutils/" rel="self" type="application/rss+xml"/><item><title>자바 객체 복사하기 ( feat. how to use CloneUtils? )</title><link>https://taetaetae.github.io/2018/08/21/how-to-use-cloneutils/</link><pubDate>Tue, 21 Aug 2018 18:02:47 +0000</pubDate><author>Author</author><guid>https://taetaetae.github.io/2018/08/21/how-to-use-cloneutils/</guid><description><![CDATA[<div class="featured-image">
                <img src="/images/how-to-use-cloneUtils/clone_java.jpg" referrerpolicy="no-referrer">
            </div>자바(Java)로 개발을 하다보면 한번쯤 객체를 복사하는 로직을 작성할때가 있다. 그때마다 나오는 이야기인 Shalldow Copy 와 Deep Copy. 한국어로 표현하면 얕은 복사와 깊은 복사라고 이야기를 하는데 이 두 개념의 차이는 아주 간단하다. 객체의 주소값을 복사하는지, 아니면 객체의 실제 값(value)를 복사하는지. 이 둘의 차이점을 소개하는 글들은 워낙 많으니 패스하도록 하고 이번 포스팅에서는 Deep Copy를 할때 org.apache.http.client.utils 하위에 있는 CloneUtils 사용법에 대해 정리 하고자 한다.
 그냥 쓰면 되는거 아닌가? 라고 생각했지만 (별거 아니라고 생각했지만) 해보고 안해보고의 차이는 엄청컸고 사용할때 주의점이 몇가지 있어 정리 하려고 한다.
 예제에 앞서 본 포스팅에서 사용할 객체를 간단히 정리하면 다음과 같다. (학교에서 학생 신상정보를 관리한다고 가정해보자.)
public class Student { String name; // 이름 	int age; // 나이 	Family family; // 가족 } public class Family { String name; // 이름 	int age; // 나이 	boolean isOfficeWorkers; // 직장인 여부 } public class PhysicalInformation { int height; // 키 	int weight; // 몸무게 } 객체는 Cloneable interface 를 implement 해야하고 clone 메소드를 public 으로 override 해야한다. 당연한 이야기가 될수도 있으나 CloneUtils를 사용하기 위해서는 해당 객체는 Cloneable interface 를 implement 해야한다. 그리고 나서 clone 메소드를 override 해야되는데 여기서 가장 중요한점은 외부에서도 호출이 가능해야하기 때문에 public 으로 override를 해야한다. (기본은 protected 로 되어있다.) 우선 간단히 객체를 생성하고 출력부터 해보자. (출력을 이쁘게 하기 위해 ToStringBuilder.reflectionToString을 사용하였다.)
PhysicalInformation physicalInformation = new PhysicalInformation(); physicalInformation.height = 180; physicalInformation.weight = 70; System.out.println(ToStringBuilder.reflectionToString(physicalInformation, ToStringStyle.DEFAULT_STYLE)); 결과는 당연히
PhysicalInformation@5d6f64b1[height=180,weight=70] 이제 Cloneable interface 를 implement 하고 clone 메소드를 public 으로 override 한뒤, CloneUtils를 사용해서 객체를 복사해보자. 테스트를 하면서 Shalldow Copy도 해보자.
// class setting public class PhysicalInformation implements Cloneable{ int height; int weight; @Override public Object clone() throws CloneNotSupportedException { // public 으로 바꿔주자. 	return super.clone(); } } // test code PhysicalInformation physicalInformation = new PhysicalInformation(); physicalInformation.height = 180; physicalInformation.weight = 70; PhysicalInformation physicalInformationShalldowCopy = physicalInformation; PhysicalInformation physicalInformationDeepCopy = null; try { physicalInformationDeepCopy = (PhysicalInformation)CloneUtils.clone(physicalInformation); } catch (CloneNotSupportedException e) { e.printStackTrace(); } // 원본 System.out.println(ToStringBuilder.reflectionToString(physicalInformation, ToStringStyle.DEFAULT_STYLE)); // 얕은 복사 System.out.println(ToStringBuilder.reflectionToString(physicalInformationShalldowCopy, ToStringStyle.DEFAULT_STYLE)); // 깊은 복사 System.out.println(ToStringBuilder.reflectionToString(physicalInformationDeepCopy, ToStringStyle.DEFAULT_STYLE)); // 값 변경 physicalInformation.weight = 80; physicalInformation.height = 170; // 원본 System.out.println(ToStringBuilder.reflectionToString(physicalInformation, ToStringStyle.DEFAULT_STYLE)); // 얕은 복사 System.out.println(ToStringBuilder.reflectionToString(physicalInformationShalldowCopy, ToStringStyle.DEFAULT_STYLE)); // 깊은 복사 System.out.println(ToStringBuilder.reflectionToString(physicalInformationDeepCopy, ToStringStyle.DEFAULT_STYLE)); 결과는 원본과 얕은 복사를 한것은 메모리 주소(?)가 같으나 깊은 복사를 한것은 데이터는 같지만 주소가 다르고 값을 변경해도 영향을 주지 않는다. (완전히 서로다른 객체인것을 증명)
PhysicalInformation@1376c05c[height=180,weight=70] PhysicalInformation@1376c05c[height=180,weight=70] PhysicalInformation@1b4fb997[height=180,weight=70] PhysicalInformation@1376c05c[height=170,weight=80] PhysicalInformation@1376c05c[height=170,weight=80] PhysicalInformation@1b4fb997[height=180,weight=70] 만약 위에서 clone을 기본값인 protected로 override를 하게 되면 어떤 결과를 가져올까?
Exception in thread &#34;main&#34; java.lang.NoSuchMethodError: com.PhysicalInformation.clone() at org.apache.http.client.utils.CloneUtils.cloneObject(CloneUtils.java:55) at org.apache.http.client.utils.CloneUtils.clone(CloneUtils.java:77) at com.Test.main(Test.java:16) 접근제한자에서 눈치를 챌수도 있었겠지만 접근을 할수없어 CloneUtils 이 리플렉션을 하는 과정에서 Exception을 발생한다. 꼭! public 으로 override를 해주자.
객체 내에 clone이 안되는 변수는 별도 처리가 필요하다. 객체 내에 있는 멤버 변수는 원시 변수(int, char, float 등) , Immutable Class (String, Boolean, Integer 등) 또는 Enum 형식일 때는 원본의 값을 바로 대입해도 되지만, 그렇지 않을 때는 멤버변수의 clone을 호출하여 복사해야 한다. 말로만 보면 무슨이야기 인지 모르니 예제를 보자.
public class Student implements Cloneable { String name; int age; Family family; @Override public Object clone() throws CloneNotSupportedException { return super.clone(); } } Student 클래스에서 Cloneable 를 implements 하고 clone 메소드를 override 하였다. (여기서 구멍이 있다!]]></description></item></channel></rss>