<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>date - Tag - 👨‍💻꿈꾸는 태태태의 공간</title><link>https://taetaetae.github.io/tags/date/</link><description>date - Tag - 👨‍💻꿈꾸는 태태태의 공간</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Thu, 23 Mar 2017 11:16:05 +0000</lastBuildDate><atom:link href="https://taetaetae.github.io/tags/date/" rel="self" type="application/rss+xml"/><item><title>Oracle + Mybatis 환경에서의 Date 다루기</title><link>https://taetaetae.github.io/2017/03/23/oracle-mybatis-date/</link><pubDate>Thu, 23 Mar 2017 11:16:05 +0000</pubDate><author>Author</author><guid>https://taetaetae.github.io/2017/03/23/oracle-mybatis-date/</guid><description><![CDATA[<div class="featured-image">
                <img src="/images/oracle-mybatis-date/oracle_mybatis_date.png" referrerpolicy="no-referrer">
            </div>상황  Oracle, Java 8, mybatis3 환경 Date컬럼에 데이터가 있는데 이를 select query로 조회하여 Model에 바인딩 시키고자 함.   쿼리에 아무 기능을 추가하지 않고 Date 형태로 Model에 바인딩을 하면 시분초가 없어진 2017-01-01 00:00:00 형태로 남게됨 그래서 아래처럼 쿼리 작성할 때마다 TO_CHAR를 사용해서 포맷에 맞추어 형변환을 시키고 Date 또는 String으로 Model에 바인딩 하곤 했음.  SELECT TO_CHAR(reg_ymdt, &#39;YYYY-MM-DD HH24:MI:SS&#39;) AS registDate FROM ...  이렇게 하다보니 query 만들때마다 형변환하는 쿼리를 만들어줘야하고, 자칫 포맷형식을 다르게 적으면 엉뚱한 결과를 초래하거나, Date형을 그대로 받아 사용해야하는 상황에서는 다시 형변환하는 과정(String to Date)을 해줘야만 함. .. 귀차니즘의 시작 : 삽질  1. 삽질의 시작 1-1. 오라클의 DATE형 → java.sql.Date 의 경우  mybatis에서는 자동적으로 org.apache.ibatis.type.SqlDateTypeHandler를 호출하게됨 mybatis 3 문서 참고 해당 핸들러의 내부 데이터 변환 코드는 다음과 같음  @Override public Date getNullableResult(ResultSet rs, String columnName) throws SQLException { return rs.getDate(columnName); }  java.sql.ResultSet.getDate()메소드를 호출하면 실제 &lsquo;yyyy-mm-dd&rsquo; 만 가져와 리턴하게됨 (여기서 디버깅 해보면 rs.getTimestamp(columnName)값은 시분초까지 다 들어가 있음) 따라서 시간값이 없는 yyyy-mm-dd 형태로 리턴이 됨  1-2. 오라클의 DATE형 → java.util.Date 의 경우  mybatis에서는 자동적으로 org.apache.ibatis.type.DateOnlyTypeHandler를 호출하게됨 mybatis 3 문서 참고 해당 핸들러의 내부 데이터 변환 코드는 다음과 같음  @Override public Date getNullableResult(ResultSet rs, String columnName) throws SQLException { java.sql.Date sqlDate = rs.getDate(columnName); if (sqlDate != null) { return new java.util.Date(sqlDate.getTime()); } return null; }  위의 org.apache.ibatis.type.SqlDateTypeHandler 변환코드에서 발생한 문제점과 같이 yyyy-mm-dd 만 가져와서 java.sql.Date 객체를 만들고, 이 정보를 토대로 java.util.Date 객체를 만들게 되는데 앞서 시간값을 뺀 정보로 만들어졌기 때문에 결국 동일하게 yyyy-mm-dd 형태로 리턴이 됨  2. 삽질완료, 해결의 시작  오라클 + mybatis 환경에서 Date타입을 다루기 위해서는 타입핸들러를 명시적으로 만들어줘야 한다는걸 알게됨.  2-1. 오라클의 DATE형 → java.sql.Date 의 경우  아래처럼 코드를 작성하여 커스텀 핸들러를 만들어 등록을 시켜준다. mybatis-config.xml  &lt;typeHandlers&gt; &lt;typeHandler handler=&#34;com.naver.dbill.admin.common.handler.CustomDateHandler&#34;/&gt; &lt;/typeHandlers&gt;  CustomDateHandler.java  ... import java.sql.Date; ... public class CustomDateHandler extends BaseTypeHandler&lt;Date&gt; { ... @Override public Date getNullableResult(ResultSet rs, String columnName) throws SQLException { Timestamp sqlTimestamp = rs.getTimestamp(columnName); if (sqlTimestamp != null) { return new Date(sqlTimestamp.getTime()); } return null; } ... }  위 코드를 작성하고 실행해보면 정상적으로 시분초 값이 있는 완전한 Date 형태를 볼수 있다.  2-2. 오라클의 DATE형 → java.util.Date 의 경우  아래처럼 코드를 작성하여 커스텀 핸들러를 만들어 등록을 시켜준다. 단, mybatis 3 문서를 보면 java.sql.Date 와는 다르게 기본으로 설정된 typeHandler가 JDBC에 따라 3가지가 있다. 따라서 작성한 커스텀 핸들러를 적용하기 위해서는 명시적으로 자바타입 과 JDBC타입 을 적어줘야 정상적으로 오버라이딩이 되어 해당 핸들러를 사용하게 된다. mybatis-config.xml  &lt;typeHandlers&gt; &lt;typeHandler handler=&#34;com.naver.dbill.admin.common.handler.CustomDateHandler&#34; javaType=&#34;java.util.Date&#34; jdbcType=&#34;DATE&#34;/&gt; &lt;/typeHandlers&gt;  CustomDateHandler.java 는 위와 동일하다. ( import java.util.Date; 사용으로 변경 )  삽질하며 알게된 보너스 지식  java.sql.Date 는 java.util.Date 을 상속받았다.  public class Date extends java.util.Date { }  검색을 하다보면 알수있겠지만 java.sql.Date 는 JDBC등을 이용해서 데이터베이스의 데이터를 사용하는데 적합하고, java.util.Date 은 보다 범용적인 날짜나 시각정보를 다룰때 적합하다고 한다. toString 메소드의 리턴 Format 형태  java.sql.Date : yyyy-mm-dd java.util.Date : EEE MMM dd HH:mm:ss zzz yyyy   mybatis 에서 형변환은 mybatis 3 문서에 나와있는 자바타입과 JDBC타입이 일치할 경우에 해당 타입 핸들러를 기본으로 사용하게 된다.  정상혁 님 조언 ( http://d2.naver.com/helloworld/645609 작성하신분 )  Oracle의 JDBC 드라이버가 예상 밖으로 동작하네요.]]></description></item><item><title>자바 8 Date</title><link>https://taetaetae.github.io/2017/01/10/java8-date/</link><pubDate>Tue, 10 Jan 2017 20:55:33 +0000</pubDate><author>Author</author><guid>https://taetaetae.github.io/2017/01/10/java8-date/</guid><description><![CDATA[<div class="featured-image">
                <img src="/images/java8-date/java_date.png" referrerpolicy="no-referrer">
            </div>이제까지 내 기억으로는 Date 관련 클래스를 아래처럼 점차 바꿔써온걸로 기억이 난다. java.util.Date &gt; java.util.Calendar &gt; org.joda.time 그런데 java 8 버전에서 기존에 있었던 문제들을 개선해서 나왔다고 한다. (네이버 HellowWorld 포스팅 참고) JSR-310 이라는 표준명세로.
지금부터는 JAVA 8 에서 제공하는 API로 날짜 연산을 어떻게 하는지에 대해 알아보고자 한다. (물론 수많은 날짜 연산 방법을이 있지만 자주 쓰이는 부분들 위주로 정리해보자.)
 Date &gt; String (format)  LocalDateTime.now().format(DateTimeFormatter.ofPattern(&#34;yyyy-MM-dd&#34;));  String &gt; Date (format)  LocalDateTime.parse(&#34;2017-01-01 12:30:00&#34;, DateTimeFormatter.ofPattern(&#34;yyyy-MM-dd HH:mm:ss&#34;));  날짜/시간 증감  LocalDateTime localDateTime = LocalDateTime.of(2017, 1, 1, 10, 0, 0); localDateTime.plusDays(1); // 일 localDateTime.plusMonths(1); // 월 localDateTime.plusHours(1); // 시간 localDateTime.plusWeeks(1); // 주 localDateTime.minusYears(1); // 년 localDateTime.minusMinutes(1); // 분 더 다양한 내용들은 아래 URL 에서 확인이 가능하다. https://docs.oracle.com/javase/tutorial/datetime/iso/overview.html]]></description></item></channel></rss>